/* Copyright (c) Fortanix, Inc.
 *
 * Licensed under the GNU General Public License, version 2 <LICENSE-GPL or
 * https://www.gnu.org/licenses/gpl-2.0.html> or the Apache License, Version
 * 2.0 <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0>, at your
 * option. This file may not be copied, modified, or distributed except
 * according to those terms. */

extern crate pkcs12;

mod tests {

    #[test]
    fn parse_shibboleth() {
        // Test from OpenSSL
        let pfx_bits = include_bytes!("data/shibboleth.pfx");
        let password = "σύνθημα γνώρισμα";

        let parsed_pfx = pkcs12::PFX::parse(pfx_bits).unwrap();

        // Certs are not encrypted in this PFX
        let certs = parsed_pfx.certificates().unwrap();
        assert_eq!(certs.len(), 1);
        assert_eq!(certs[0].1.len(), 0); // no friendly name set

        let keys = parsed_pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 0);

        let pfx = parsed_pfx.decrypt(&password).unwrap();

        let certs = pfx.certificates().unwrap();
        assert_eq!(certs.len(), 1);

        let keys = pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 1);

        assert_eq!(keys[0].1.len(), 1); // has friendly name
        assert_eq!(keys[0].1[0], "3f71af65-1687-444a-9f46-c8be194c3e8e"); // which is this uuid
        assert_eq!(keys[0].0.name().unwrap(), "RSA");
        assert_eq!(keys[0].0.len(), 2048);
    }

    #[test]
    #[cfg(feature="rc2_encryption")]
    fn parse_identity_p12() {
        // Used in rust-native-tls examples

        let pfx_bits = include_bytes!("data/identity.p12");
        let password = "mypass";

        let parsed_pfx = pkcs12::PFX::parse(pfx_bits).unwrap();

        let certs = parsed_pfx.certificates().unwrap();
        assert_eq!(certs.len(), 0);

        let keys = parsed_pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 0);

        let pfx = parsed_pfx.decrypt(&password).unwrap();

        let certs = pfx.certificates().unwrap();
        assert_eq!(certs.len(), 2);

        let keys = pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 1);

        assert_eq!(keys[0].1.len(), 1); // has friendly name
        assert_eq!(keys[0].1[0], "foobar.com");
        assert_eq!(keys[0].0.name().unwrap(), "RSA");
        assert_eq!(keys[0].0.len(), 2048);
    }

    #[test]
    fn parse_pkijs_p12() {
        // This one is not encrypted at all

        let pfx_bits = include_bytes!("data/pkijs_pkcs12.p12");

        let parsed_pfx = pkcs12::PFX::parse(pfx_bits).unwrap();

        let certs = parsed_pfx.certificates().unwrap();
        assert_eq!(certs.len(), 1);

        let keys = parsed_pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 1);

        assert_eq!(keys[0].1.len(), 0); // no name
        assert_eq!(keys[0].0.name().unwrap(), "RSA");
        assert_eq!(keys[0].0.len(), 2048);
    }

    #[test]
    #[cfg(feature="rc2_encryption")]
    fn parse_windows_p12() {
        // Generated by Windows CryptoAPI with empty password
        let pfx_bits = include_bytes!("data/MetroTestCertificate.pfx");
        let password = "";

        let parsed_pfx = pkcs12::PFX::parse(pfx_bits).unwrap();

        let pfx = parsed_pfx.decrypt(&password).unwrap();

        let certs = pfx.certificates().unwrap();
        assert_eq!(certs.len(), 1);

        let keys = pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 1);

        assert_eq!(keys[0].1.len(), 1); // no name
        assert_eq!(keys[0].1[0], "Unity");
        assert_eq!(keys[0].0.name().unwrap(), "RSA");
        assert_eq!(keys[0].0.len(), 2048);
    }

    #[test]
    fn parse_windows_p12_2() {
        // Generated by Windows CryptoAPI
        let pfx_bits = include_bytes!("data/Windows_TemporaryKey.pfx");
        let password = "";

        let pfx = pkcs12::PFX::parse(pfx_bits).unwrap();

        // Cert is not encrypted
        let certs = pfx.certificates().unwrap();
        assert_eq!(certs.len(), 1);

        let keys = pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 0);

        let pfx = pfx.decrypt(&password).unwrap();

        let keys = pfx.private_keys().unwrap();
        assert_eq!(keys.len(), 1);

        assert_eq!(keys[0].1.len(), 1); // no name
        assert_eq!(keys[0].1[0], "PvkTmp:7708e756-dd3f-4399-bb07-f0b5b4f41c1b");
        assert_eq!(keys[0].0.name().unwrap(), "RSA");
        assert_eq!(keys[0].0.len(), 2048);
    }

}
